''' 
    _   _   _   _     _   _   _   _   _  
   / \ / \ / \ / \   / \ / \ / \ / \ / \ 
  ( V | i | r | u ) ( C | h | o | r | d )
   \_/ \_/ \_/ \_/   \_/ \_/ \_/ \_/ \_/ 
   
   Written By Louis Cochrane in Collaboration with Derek Gatherer 
   Lancaster University
   All Rights Reserved
   
   This script uses the notes of a stockhausen scale
   to convert a FASTA file into a chord progression 
   with the aim of being able to better 'hear' the 
   change in nucleotides over time compared to 
   traditional methods. 
   
   This project is primarily intended to sonically
   map the Zaire Ebola Virus outbreak, but there 
   may be other applications. 
   
   Have fun!
   
   - Louis

'''

import time
import datetime
import os 
import os.path
import shutil
import sys
from datetime import datetime
from dependencies.pydub import AudioSegment
from dependencies.FASTAKit import Seq

""" # Dependencies Note
Program will always initialise into the dependencies directory. 
Use cd_root if you need to access or write files to the 
root directory. Just remember to call cd_dependencies
to go back to the dependencies directory afterwards. 
"""

os.chdir(".\dependencies")


class GlobalParameters:
    versionNumber = "3.0"
    currentlySupportedSequenceLength = None
    chordSmoothing = True


def set_global_parameters():
    """
    Function that analyses file structure and available 
    material in order to intelligently set the global 
    paramaters of the program.
    """
    
    # Analyses how many sound files have been provided
    # to determine what the maximum supported sequence
    # length is. 
    
    for i in range(50):
        try:
            testFile = composition = AudioSegment.from_wav(str(i) + ".wav")
            GlobalParameters.currentlySupportedSequenceLength = i + 1
        except:
            break
    
    return


def newLine():
    print("\n")


def cd_root():
    os.chdir("..")


def cd_dependencies():
    os.chdir(".\dependencies")


def generate_chord_library(filename,convertToRY): # Deprecated
    
    """
    This function uses pydub to generate a library of chords that will 
    be used to build the composition. 
    Also returns an 'outputRecord' that denotes the names of all 
    chords generated by this function. To be used for assembly.
    """
    
    # Create a sequence object using my FASTAKit Library. 
    # .fasta files should be placed in the root directory. 
    # So we change directory then back to access them. 
    
    cd_root()
    sequences = Seq(filename)
    cd_dependencies()

    if convertToRY == True:
        
        sequences.convertToRY()

    
    # Grab the raw sequence List Data. 
    sequenceList = sequences.seqList()
    
    # Let's first check that the sequence length doesnt exceed
    # the currently supported sequence length, as determined
    # in global variables. 
    
    for sequence in sequenceList:
        
        if len(sequence) > GlobalParameters.currentlySupportedSequenceLength:
            
            newLine()
            print("ERROR: Sequence length exceeds maximum supported length.")
            print("Currently supported max sequence length:",Globals.currentlySupportedSequenceLength)
            print("Highest sequence length found in FASTA File:",len(sequence))
            newLine()
            
            return None

    # Now let's check if all sequences are the same length, if not, no good!
    
    testLength = len(sequenceList[0])
    for sequence in sequenceList:
        if len(sequence) != testLength:
            newLine()
            print("ERROR: All sequences must be the same length.")
            print("First Abberent Sequence:", sequence)
            newLine()
            return None
            
    # Grab the first sequence, this is what we will compare to to see 
    # if each tone should be turned on or off. 
    comparisonSequence = sequenceList[0]
    
    # Ok so now we need a loop to interate through and compare each 
    # sequence to the initial sequence. 
    listIndex = 0 
    
    # This list will keep track of the generated chord files for later use
    # when building a final composition. It is returned from the function. 
    outputRecord = []
    
    for sequence in sequenceList:
    
        nucleotideIndex = 0 
        buildList = []
        
        for nucleotide in sequenceList[listIndex]:

            if nucleotide == comparisonSequence[nucleotideIndex]:
               
                filename = str(nucleotideIndex) + ".wav"
                tone = AudioSegment.from_wav(filename)
                buildList.append(tone)
        
            nucleotideIndex += 1 
        
        # If the list is empty, we'll just generate and 
        # export a silent chord using a premade silence wav. 
        
        if buildList == []:
            
            composition = AudioSegment.from_wav("s.wav")
            composition.export("Chord" + str(listIndex) + ".wav",format="wav")
            outputRecord.append("Chord" + str(listIndex) + ".wav") 

        # Otherwise we can actually do the building and export. 
        
        else:
            
            # New 500ms audio segment (Same length as each note.)
            composition = AudioSegment.silent(500)

            # This little loop is there to reduce the volume of each note of a chord.
            # Proportionally to how many notes are added, to avoid distortion. 
            
            for note in buildList:
                
                #***********************************************
                # Modify the integer here to adjust volume. 
                # 5 seems roughly correct, but this may change. 
                note = note - (4 * len(buildList))
                #**********************************************
                
                composition = composition.overlay(note)
            
            # Adding the chord name to the output record.
            outputRecord.append("Chord" + str(listIndex) + ".wav") 
            
            # Exporting each chord using the current index as a name!
            composition.export("Chord" + str(listIndex) + ".wav",format="wav")

        # Increment the outer index to keep the naming correct!
        listIndex +=1 
    
    newLine()
    outputRecord.append("c")
    return outputRecord


def generate_chord_library_alternate(filename,convertToRY): # Deprecated
    
    
    """
    Alternative chord generation, instead of notes turning off when they are mutated 
    they instead switch to a slightly higher note. 
    
    """
    
    # Create a sequence object using my FASTAKit Library. 
    # .fasta files should be placed in the root directory. 
    # So we change directory then back to access them. 
    
    cd_root()
    sequences = Seq(filename)
    cd_dependencies()

    if convertToRY == True:
        
        sequences.convertToRY()

    
    # Grab the raw sequence List Data. 
    sequenceList = sequences.seqList()
    
    # Let's first check that the sequence length doesnt exceed
    # the currently supported sequence length, as determined
    # in global variables. 
    
    for sequence in sequenceList:
        
        if len(sequence) > GlobalParameters.currentlySupportedSequenceLength:
            
            newLine()
            print("ERROR: Sequence length exceeds maximum supported length.")
            print("Currently supported max sequence length:",Globals.currentlySupportedSequenceLength)
            print("Highest sequence length found in FASTA File:",len(sequence))
            newLine()
            
            return None

    # Now let's check if all sequences are the same length, if not, no good!
    
    testLength = len(sequenceList[0])
    for sequence in sequenceList:
        if len(sequence) != testLength:
            newLine()
            print("ERROR: All sequences must be the same length.")
            print("First Abberent Sequence:", sequence)
            newLine()
            return None
            
    # Grab the first sequence, this is what we will compare to to see 
    # if each tone should be turned on or off. 
    comparisonSequence = sequenceList[0]
    
    # Ok so now we need a loop to interate through and compare each 
    # sequence to the initial sequence. 
    listIndex = 0 
    
    # This list will keep track of the generated chord files for later use
    # when building a final composition. It is returned from the function. 
    outputRecord = []
    
    for sequence in sequenceList:
    
        nucleotideIndex = 0 
        buildList = []
        samesList = []
        
        for nucleotide in sequenceList[listIndex]:

            if nucleotide == comparisonSequence[nucleotideIndex]:
               
                filename = str(nucleotideIndex) + ".wav"
                print("APPENDING",filename)
                tone = AudioSegment.from_wav(filename)
                tone = tone - 50
                buildList.append(tone)
                samesList.append("_")
            
            # If it's not the same we will instead append the alternate tone.     
            else:
    
                filename = str(nucleotideIndex) + "a" + ".wav"
                print("APPENDING",filename)
                tone = AudioSegment.from_wav(filename)
                tone = tone - 50
                buildList.append(tone)            
        
            nucleotideIndex += 1 
            
            
            
            
        
        # If the list is empty, we'll just generate and 
        # export a silent chord using a premade silence wav. 
        
        if buildList == []:
            
            composition = AudioSegment.from_wav("s.wav")
            composition.export("Chord" + str(listIndex) + ".wav",format="wav")
            outputRecord.append("Chord" + str(listIndex) + ".wav") 

        # Otherwise we can actually do the building and export. 
        
        else:
            
            # New 500ms audio segment (Same length as each note.)
            composition = AudioSegment.silent(500)

            # This little loop is there to reduce the volume of each note of a chord.
            # Proportionally to how many notes are added, to avoid distortion. 
            
            for note in buildList:
                
                #***********************************************
                # Modify the integer here to adjust volume. 
                # 5 seems roughly correct, but this may change. 
                #note = note - (5 * len(samesList))
                #**********************************************
                
                composition = composition.overlay(note)
            
            # Adding the chord name to the output record.
            outputRecord.append("Chord" + str(listIndex) + ".wav") 
            
            # Exporting each chord using the current index as a name!
            composition.export("Chord" + str(listIndex) + ".wav",format="wav")

        # Increment the outer index to keep the naming correct!
        listIndex +=1 
        newLine()
    
    newLine()
    outputRecord.append("a")
    return outputRecord


def generate_chord_library_oscillating(filename,convertToRY): # Deprecated
    
    
    """
    Alternative chord generation, instead of notes turning off when they are mutated 
    they instead switch to a slightly higher note. 
    
    """
    
    # Create a sequence object using my FASTAKit Library. 
    # .fasta files should be placed in the root directory. 
    # So we change directory then back to access them. 
    
    cd_root()
    sequences = Seq(filename)
    cd_dependencies()

    if convertToRY == True:
        
        sequences.convertToRY()

    
    # Grab the raw sequence List Data. 
    sequenceList = sequences.seqList()
    
    # Let's first check that the sequence length doesnt exceed
    # the currently supported sequence length, as determined
    # in global variables. 
    
    for sequence in sequenceList:
        
        if len(sequence) > GlobalParameters.currentlySupportedSequenceLength:
            
            newLine()
            print("ERROR: Sequence length exceeds maximum supported length.")
            print("Currently supported max sequence length:",Globals.currentlySupportedSequenceLength)
            print("Highest sequence length found in FASTA File:",len(sequence))
            newLine()
            
            return None

    # Now let's check if all sequences are the same length, if not, no good!
    
    testLength = len(sequenceList[0])
    for sequence in sequenceList:
        if len(sequence) != testLength:
            newLine()
            print("ERROR: All sequences must be the same length.")
            print("First Abberent Sequence:", sequence)
            newLine()
            return None
            
    # Grab the first sequence, this is what we will compare to to see 
    # if each tone should be turned on or off. 
    comparisonSequence = sequenceList[0]
    
    # Ok so now we need a loop to interate through and compare each 
    # sequence to the initial sequence. 
    listIndex = 0 
    
    # This list will keep track of the generated chord files for later use
    # when building a final composition. It is returned from the function. 
    outputRecord = []
    
    for sequence in sequenceList:
    
        nucleotideIndex = 0 
        buildList = []
        differenceList = []
        
        for nucleotide in sequenceList[listIndex]:

            if nucleotide == comparisonSequence[nucleotideIndex]:
               
                filename = str(nucleotideIndex) + ".wav"
                tone = AudioSegment.from_wav(filename)
                tone = tone - 25
                buildList.append(tone)
            
            # If it's not the same we will instead append the alternate tone.     
            else:
    
                filename = str(nucleotideIndex) + "o"  + ".wav"
                tone = AudioSegment.from_wav(filename)
                differenceList.append("_")
                if len(differenceList) >= 4:
                    tone = tone - 25
                else:
                    tone = tone - 5 
                buildList.append(tone)            
        
            nucleotideIndex += 1 
            
            
        
        # If the list is empty, we'll just generate and 
        # export a silent chord using a premade silence wav. 
        
        if buildList == []:
            
            composition = AudioSegment.from_wav("s.wav")
            composition.export("Chord" + str(listIndex) + ".wav",format="wav")
            outputRecord.append("Chord" + str(listIndex) + ".wav") 

        # Otherwise we can actually do the building and export. 
        
        else:
            
            # New 500ms audio segment (Same length as each note.)
            composition = AudioSegment.silent(500)

            # This little loop is there to reduce the volume of each note of a chord.
            # Proportionally to how many notes are added, to avoid distortion. 
            
            for note in buildList:
                
                #***********************************************
                # Modify the integer here to adjust volume. 
                # 5 seems roughly correct, but this may change. 
                #note = note - (5 * len(samesList))
                #**********************************************
                
                composition = composition.overlay(note)
            
            # Adding the chord name to the output record.
            outputRecord.append("Chord" + str(listIndex) + ".wav") 
            
            # Exporting each chord using the current index as a name!
            composition.export("Chord" + str(listIndex) + ".wav",format="wav")

        # Increment the outer index to keep the naming correct!
        listIndex +=1 
    
    newLine()
    outputRecord.append("o")
    return outputRecord


def generate_chord_library_alternate_oscillating(filename,convertToRY): # Deprecated
    
    
    """
    Alternative chord generation, instead of notes turning off when they are mutated 
    they instead switch to a slightly higher note. 
    
    """
    
    # Create a sequence object using my FASTAKit Library. 
    # .fasta files should be placed in the root directory. 
    # So we change directory then back to access them. 
    
    cd_root()
    sequences = Seq(filename)
    cd_dependencies()

    if convertToRY == True:
        
        sequences.convertToRY()

    
    # Grab the raw sequence List Data. 
    sequenceList = sequences.seqList()
    
    # Let's first check that the sequence length doesnt exceed
    # the currently supported sequence length, as determined
    # in global variables. 
    
    for sequence in sequenceList:
        
        if len(sequence) > GlobalParameters.currentlySupportedSequenceLength:
            
            newLine()
            print("ERROR: Sequence length exceeds maximum supported length.")
            print("Currently supported max sequence length:",Globals.currentlySupportedSequenceLength)
            print("Highest sequence length found in FASTA File:",len(sequence))
            newLine()
            
            return None

    # Now let's check if all sequences are the same length, if not, no good!
    
    testLength = len(sequenceList[0])
    for sequence in sequenceList:
        if len(sequence) != testLength:
            newLine()
            print("ERROR: All sequences must be the same length.")
            print("First Abberent Sequence:", sequence)
            newLine()
            return None
            
    # Grab the first sequence, this is what we will compare to to see 
    # if each tone should be turned on or off. 
    comparisonSequence = sequenceList[0]
    
    # Ok so now we need a loop to interate through and compare each 
    # sequence to the initial sequence. 
    listIndex = 0 
    
    # This list will keep track of the generated chord files for later use
    # when building a final composition. It is returned from the function. 
    outputRecord = []
    
    for sequence in sequenceList:
    
        nucleotideIndex = 0 
        buildList = []
        differenceList = []
        
        for nucleotide in sequenceList[listIndex]:

            if nucleotide == comparisonSequence[nucleotideIndex]:
               
                filename = str(nucleotideIndex) + ".wav"
                tone = AudioSegment.from_wav(filename)
                tone = tone - 25
                buildList.append(tone)
            
            # If it's not the same we will instead append the alternate tone.     
            else:
    
                filename = str(nucleotideIndex) + "a" + "o"  + ".wav"
                tone = AudioSegment.from_wav(filename)
                differenceList.append("_")
                if len(differenceList) >= 4:
                    tone = tone - 25
                else:
                    tone = tone - 5 
                buildList.append(tone)            
        
            nucleotideIndex += 1 
            
            
        
        # If the list is empty, we'll just generate and 
        # export a silent chord using a premade silence wav. 
        
        if buildList == []:
            
            composition = AudioSegment.from_wav("s.wav")
            composition.export("Chord" + str(listIndex) + ".wav",format="wav")
            outputRecord.append("Chord" + str(listIndex) + ".wav") 

        # Otherwise we can actually do the building and export. 
        
        else:
            
            # New 500ms audio segment (Same length as each note.)
            composition = AudioSegment.silent(500)

            # This little loop is there to reduce the volume of each note of a chord.
            # Proportionally to how many notes are added, to avoid distortion. 
            
            for note in buildList:
                
                #***********************************************
                # Modify the integer here to adjust volume. 
                # 5 seems roughly correct, but this may change. 
                #note = note - (5 * len(samesList))
                #**********************************************
                
                composition = composition.overlay(note)
            
            # Adding the chord name to the output record.
            outputRecord.append("Chord" + str(listIndex) + ".wav") 
            
            # Exporting each chord using the current index as a name!
            composition.export("Chord" + str(listIndex) + ".wav",format="wav")

        # Increment the outer index to keep the naming correct!
        listIndex +=1 
    
    newLine()
    outputRecord.append("ao")
    return outputRecord


def generate_chord_library_minimal(filename,convertToRY): # Deprecated
    
    
    """
    Alternative chord generation, instead of notes turning off when they are mutated 
    they instead switch to a slightly higher note. 
    
    """
    
    # Create a sequence object using my FASTAKit Library. 
    # .fasta files should be placed in the root directory. 
    # So we change directory then back to access them. 
    
    cd_root()
    sequences = Seq(filename)
    cd_dependencies()

    if convertToRY == True:
        
        sequences.convertToRY()

    
    # Grab the raw sequence List Data. 
    sequenceList = sequences.seqList()
    
    # Let's first check that the sequence length doesnt exceed
    # the currently supported sequence length, as determined
    # in global variables. 
    
    for sequence in sequenceList:
        
        if len(sequence) > GlobalParameters.currentlySupportedSequenceLength:
            
            newLine()
            print("ERROR: Sequence length exceeds maximum supported length.")
            print("Currently supported max sequence length:",Globals.currentlySupportedSequenceLength)
            print("Highest sequence length found in FASTA File:",len(sequence))
            newLine()
            
            return None

    # Now let's check if all sequences are the same length, if not, no good!
    
    testLength = len(sequenceList[0])
    for sequence in sequenceList:
        if len(sequence) != testLength:
            newLine()
            print("ERROR: All sequences must be the same length.")
            print("First Abberent Sequence:", sequence)
            newLine()
            return None
            
    # Grab the first sequence, this is what we will compare to to see 
    # if each tone should be turned on or off. 
    comparisonSequence = sequenceList[0]
    
    # Ok so now we need a loop to interate through and compare each 
    # sequence to the initial sequence. 
    listIndex = 0 
    
    # This list will keep track of the generated chord files for later use
    # when building a final composition. It is returned from the function. 
    outputRecord = []
    
    for sequence in sequenceList:
    
        nucleotideIndex = 0 
        buildList = []

        
        tone = AudioSegment.from_wav("d.wav")
        tone = tone - 25
        buildList.append(tone)
        
        for nucleotide in sequenceList[listIndex]:

            if nucleotide == comparisonSequence[nucleotideIndex]:
               
                pass

            # If it's not the same we will instead append the alternate tone.     
            else:
    
                filename = str(nucleotideIndex) + ".wav"
                tone = AudioSegment.from_wav(filename)
                tone = tone - 35
                buildList.append(tone)            
        
            nucleotideIndex += 1 
            
            
        
        # If the list is empty, we'll just generate and 
        # export a silent chord using a premade silence wav. 
        
        if buildList == []:
            
            composition = AudioSegment.from_wav("s.wav")
            composition.export("Chord" + str(listIndex) + ".wav",format="wav")
            outputRecord.append("Chord" + str(listIndex) + ".wav") 

        # Otherwise we can actually do the building and export. 
        
        else:
            
            # New 500ms audio segment (Same length as each note.)
            composition = AudioSegment.silent(500)

            # This little loop is there to reduce the volume of each note of a chord.
            # Proportionally to how many notes are added, to avoid distortion. 
            
            for note in buildList:
                
                #***********************************************
                # Modify the integer here to adjust volume. 
                # 5 seems roughly correct, but this may change. 
                #note = note - (5 * len(samesList))
                #**********************************************
                
                composition = composition.overlay(note)
            
            # Adding the chord name to the output record.
            outputRecord.append("Chord" + str(listIndex) + ".wav") 
            
            # Exporting each chord using the current index as a name!
            composition.export("Chord" + str(listIndex) + ".wav",format="wav")

        # Increment the outer index to keep the naming correct!
        listIndex +=1 
    
    newLine()
    outputRecord.append("m")
    return outputRecord


def generate_chord_library_minimal_alternate(filename,convertToRY): # Deprecated
    
    
    """
    Alternative chord generation, instead of notes turning off when they are mutated 
    they instead switch to a slightly higher note. 
    
    """
    
    # Create a sequence object using my FASTAKit Library. 
    # .fasta files should be placed in the root directory. 
    # So we change directory then back to access them. 
    
    cd_root()
    sequences = Seq(filename)
    cd_dependencies()

    if convertToRY == True:
        
        sequences.convertToRY()

    
    # Grab the raw sequence List Data. 
    sequenceList = sequences.seqList()
    
    # Let's first check that the sequence length doesnt exceed
    # the currently supported sequence length, as determined
    # in global variables. 
    
    for sequence in sequenceList:
        
        if len(sequence) > GlobalParameters.currentlySupportedSequenceLength:
            
            newLine()
            print("ERROR: Sequence length exceeds maximum supported length.")
            print("Currently supported max sequence length:",Globals.currentlySupportedSequenceLength)
            print("Highest sequence length found in FASTA File:",len(sequence))
            newLine()
            
            return None

    # Now let's check if all sequences are the same length, if not, no good!
    
    testLength = len(sequenceList[0])
    for sequence in sequenceList:
        if len(sequence) != testLength:
            newLine()
            print("ERROR: All sequences must be the same length.")
            print("First Abberent Sequence:", sequence)
            newLine()
            return None
            
    # Grab the first sequence, this is what we will compare to to see 
    # if each tone should be turned on or off. 
    comparisonSequence = sequenceList[0]
    
    # Ok so now we need a loop to interate through and compare each 
    # sequence to the initial sequence. 
    listIndex = 0 
    
    # This list will keep track of the generated chord files for later use
    # when building a final composition. It is returned from the function. 
    outputRecord = []
    
    for sequence in sequenceList:
    
        nucleotideIndex = 0 
        buildList = []

        
        tone = AudioSegment.from_wav("d.wav")
        tone = tone - 25
        buildList.append(tone)
        
        for nucleotide in sequenceList[listIndex]:

            if nucleotide == comparisonSequence[nucleotideIndex]:
               
                pass

            # If it's not the same we will instead append the alternate tone.     
            else:
    
                filename = str(nucleotideIndex) + "a" + ".wav"
                tone = AudioSegment.from_wav(filename)
                tone = tone - 35
                buildList.append(tone)            
        
            nucleotideIndex += 1 
            
            
        
        # If the list is empty, we'll just generate and 
        # export a silent chord using a premade silence wav. 
        
        if buildList == []:
            
            composition = AudioSegment.from_wav("s.wav")
            composition.export("Chord" + str(listIndex) + ".wav",format="wav")
            outputRecord.append("Chord" + str(listIndex) + ".wav") 

        # Otherwise we can actually do the building and export. 
        
        else:
            
            # New 500ms audio segment (Same length as each note.)
            composition = AudioSegment.silent(500)

            # This little loop is there to reduce the volume of each note of a chord.
            # Proportionally to how many notes are added, to avoid distortion. 
            
            for note in buildList:
                
                #***********************************************
                # Modify the integer here to adjust volume. 
                # 5 seems roughly correct, but this may change. 
                #note = note - (5 * len(samesList))
                #**********************************************
                
                composition = composition.overlay(note)
            
            # Adding the chord name to the output record.
            outputRecord.append("Chord" + str(listIndex) + ".wav") 
            
            # Exporting each chord using the current index as a name!
            composition.export("Chord" + str(listIndex) + ".wav",format="wav")

        # Increment the outer index to keep the naming correct!
        listIndex +=1 
    
    newLine()
    outputRecord.append("ma")
    return outputRecord


def generate_chord_library_minimal_oscillating(filename,convertToRY): # Deprecated
    
    
    """
    Alternative chord generation, instead of notes turning off when they are mutated 
    they instead switch to a slightly higher note. 
    
    """
    
    # Create a sequence object using my FASTAKit Library. 
    # .fasta files should be placed in the root directory. 
    # So we change directory then back to access them. 
    
    cd_root()
    sequences = Seq(filename)
    cd_dependencies()

    if convertToRY == True:
        
        sequences.convertToRY()

    
    # Grab the raw sequence List Data. 
    sequenceList = sequences.seqList()
    
    # Let's first check that the sequence length doesnt exceed
    # the currently supported sequence length, as determined
    # in global variables. 
    
    for sequence in sequenceList:
        
        if len(sequence) > GlobalParameters.currentlySupportedSequenceLength:
            
            newLine()
            print("ERROR: Sequence length exceeds maximum supported length.")
            print("Currently supported max sequence length:",Globals.currentlySupportedSequenceLength)
            print("Highest sequence length found in FASTA File:",len(sequence))
            newLine()
            
            return None

    # Now let's check if all sequences are the same length, if not, no good!
    
    testLength = len(sequenceList[0])
    for sequence in sequenceList:
        if len(sequence) != testLength:
            newLine()
            print("ERROR: All sequences must be the same length.")
            print("First Abberent Sequence:", sequence)
            newLine()
            return None
            
    # Grab the first sequence, this is what we will compare to to see 
    # if each tone should be turned on or off. 
    comparisonSequence = sequenceList[0]
    
    # Ok so now we need a loop to interate through and compare each 
    # sequence to the initial sequence. 
    listIndex = 0 
    
    # This list will keep track of the generated chord files for later use
    # when building a final composition. It is returned from the function. 
    outputRecord = []
    
    for sequence in sequenceList:
    
        nucleotideIndex = 0 
        buildList = []

        
        tone = AudioSegment.from_wav("d.wav")
        tone = tone - 25
        buildList.append(tone)
        
        for nucleotide in sequenceList[listIndex]:

            if nucleotide == comparisonSequence[nucleotideIndex]:
               
                pass

            # If it's not the same we will instead append the alternate tone.     
            else:
    
                filename = str(nucleotideIndex) + "o" + ".wav"
                tone = AudioSegment.from_wav(filename)
                tone = tone - 35
                buildList.append(tone)            
        
            nucleotideIndex += 1 
            
            
        
        # If the list is empty, we'll just generate and 
        # export a silent chord using a premade silence wav. 
        
        if buildList == []:
            
            composition = AudioSegment.from_wav("s.wav")
            composition.export("Chord" + str(listIndex) + ".wav",format="wav")
            outputRecord.append("Chord" + str(listIndex) + ".wav") 

        # Otherwise we can actually do the building and export. 
        
        else:
            
            # New 500ms audio segment (Same length as each note.)
            composition = AudioSegment.silent(500)

            # This little loop is there to reduce the volume of each note of a chord.
            # Proportionally to how many notes are added, to avoid distortion. 
            
            for note in buildList:
                
                #***********************************************
                # Modify the integer here to adjust volume. 
                # 5 seems roughly correct, but this may change. 
                #note = note - (5 * len(samesList))
                #**********************************************
                
                composition = composition.overlay(note)
            
            # Adding the chord name to the output record.
            outputRecord.append("Chord" + str(listIndex) + ".wav") 
            
            # Exporting each chord using the current index as a name!
            composition.export("Chord" + str(listIndex) + ".wav",format="wav")

        # Increment the outer index to keep the naming correct!
        listIndex +=1 
    
    newLine()
    outputRecord.append("mo")
    return outputRecord


def generate_chord_library_minimal_oscillating_alternate(filename,convertToRY): # Deprecated
    
    
    """
    Alternative chord generation, instead of notes turning off when they are mutated 
    they instead switch to a slightly higher note. 
    
    """
    
    # Create a sequence object using my FASTAKit Library. 
    # .fasta files should be placed in the root directory. 
    # So we change directory then back to access them. 
    
    cd_root()
    sequences = Seq(filename)
    cd_dependencies()

    if convertToRY == True:
        
        sequences.convertToRY()

    
    # Grab the raw sequence List Data. 
    sequenceList = sequences.seqList()
    
    # Let's first check that the sequence length doesnt exceed
    # the currently supported sequence length, as determined
    # in global variables. 
    
    for sequence in sequenceList:
        
        if len(sequence) > GlobalParameters.currentlySupportedSequenceLength:
            
            newLine()
            print("ERROR: Sequence length exceeds maximum supported length.")
            print("Currently supported max sequence length:",Globals.currentlySupportedSequenceLength)
            print("Highest sequence length found in FASTA File:",len(sequence))
            newLine()
            
            return None

    # Now let's check if all sequences are the same length, if not, no good!
    
    testLength = len(sequenceList[0])
    for sequence in sequenceList:
        if len(sequence) != testLength:
            newLine()
            print("ERROR: All sequences must be the same length.")
            print("First Abberent Sequence:", sequence)
            newLine()
            return None
            
    # Grab the first sequence, this is what we will compare to to see 
    # if each tone should be turned on or off. 
    comparisonSequence = sequenceList[0]
    
    # Ok so now we need a loop to interate through and compare each 
    # sequence to the initial sequence. 
    listIndex = 0 
    
    # This list will keep track of the generated chord files for later use
    # when building a final composition. It is returned from the function. 
    outputRecord = []
    
    for sequence in sequenceList:
    
        nucleotideIndex = 0 
        buildList = []

        
        tone = AudioSegment.from_wav("d.wav")
        tone = tone - 25
        buildList.append(tone)
        
        for nucleotide in sequenceList[listIndex]:

            if nucleotide == comparisonSequence[nucleotideIndex]:
               
                pass

            # If it's not the same we will instead append the alternate tone.     
            else:
    
                filename = str(nucleotideIndex) + "a" + "o" + ".wav"
                tone = AudioSegment.from_wav(filename)
                tone = tone - 35
                buildList.append(tone)            
        
            nucleotideIndex += 1 
            
            
        
        # If the list is empty, we'll just generate and 
        # export a silent chord using a premade silence wav. 
        
        if buildList == []:
            
            composition = AudioSegment.from_wav("s.wav")
            composition.export("Chord" + str(listIndex) + ".wav",format="wav")
            outputRecord.append("Chord" + str(listIndex) + ".wav") 

        # Otherwise we can actually do the building and export. 
        
        else:
            
            # New 500ms audio segment (Same length as each note.)
            composition = AudioSegment.silent(500)

            # This little loop is there to reduce the volume of each note of a chord.
            # Proportionally to how many notes are added, to avoid distortion. 
            
            for note in buildList:
                
                #***********************************************
                # Modify the integer here to adjust volume. 
                # 5 seems roughly correct, but this may change. 
                #note = note - (5 * len(samesList))
                #**********************************************
                
                composition = composition.overlay(note)
            
            # Adding the chord name to the output record.
            outputRecord.append("Chord" + str(listIndex) + ".wav") 
            
            # Exporting each chord using the current index as a name!
            composition.export("Chord" + str(listIndex) + ".wav",format="wav")

        # Increment the outer index to keep the naming correct!
        listIndex +=1 
    
    newLine()
    outputRecord.append("moa")
    return outputRecord


def generate_chord_library_modern(filename,convertToRY):
    """
    Alternative chord generation, instead of notes turning off when they are mutated 
    they instead switch to a slightly higher note. 
    
    """
    
    # Create a sequence object using my FASTAKit Library. 
    # .fasta files should be placed in the root directory. 
    # So we change directory then back to access them. 
    
    cd_root()
    sequences = Seq(filename)
    cd_dependencies()

    if convertToRY == True:
        
        sequences.convertToRY()

    
    # Grab the raw sequence List Data. 
    sequenceList = sequences.seqList()
    
    # Let's first check that the sequence length doesnt exceed
    # the currently supported sequence length, as determined
    # in global variables. 
    
    for sequence in sequenceList:
        
        if len(sequence) > GlobalParameters.currentlySupportedSequenceLength:
            
            newLine()
            print("ERROR: Sequence length exceeds maximum supported length.")
            print("Currently supported max sequence length:",Globals.currentlySupportedSequenceLength)
            print("Highest sequence length found in FASTA File:",len(sequence))
            newLine()
            
            return None

    # Now let's check if all sequences are the same length, if not, no good!
    
    testLength = len(sequenceList[0])
    for sequence in sequenceList:
        if len(sequence) != testLength:
            newLine()
            print("ERROR: All sequences must be the same length.")
            print("First Abberent Sequence:", sequence)
            newLine()
            return None
            
    # Grab the first sequence, this is what we will compare to to see 
    # if each tone should be turned on or off. 
    comparisonSequence = sequenceList[0]
    
    # Ok so now we need a loop to interate through and compare each 
    # sequence to the initial sequence. 
    listIndex = 0 
    
    # This list will keep track of the generated chord files for later use
    # when building a final composition. It is returned from the function. 
    outputRecord = []
    
    for sequence in sequenceList:
    
        nucleotideIndex = 0 
        buildList = []

        
        tone = AudioSegment.from_wav("d.wav")
        tone = tone - 25
        buildList.append(tone)
        
        for nucleotide in sequenceList[listIndex]:

            if nucleotide == comparisonSequence[nucleotideIndex]:
               
                pass

            # If it's not the same we will instead append the alternate tone.     
            else:
    
                filename = str(nucleotideIndex) + "o" + ".wav"
                tone = AudioSegment.from_wav(filename)
                tone = tone - 35
                buildList.append(tone)            
        
            nucleotideIndex += 1 
            
            
        
        # If the list is empty, we'll just generate and 
        # export a silent chord using a premade silence wav. 
        
        if buildList == []:
            
            composition = AudioSegment.from_wav("s.wav")
            composition.export("Chord" + str(listIndex) + ".wav",format="wav")
            outputRecord.append("Chord" + str(listIndex) + ".wav") 

        # Otherwise we can actually do the building and export. 
        
        else:
            
            # New 500ms audio segment (Same length as each note.)
            composition = AudioSegment.silent(500)

            # This little loop is there to reduce the volume of each note of a chord.
            # Proportionally to how many notes are added, to avoid distortion. 
            
            for note in buildList:
                
                #***********************************************
                # Modify the integer here to adjust volume. 
                # 5 seems roughly correct, but this may change. 
                #note = note - (5 * len(samesList))
                #**********************************************
                
                composition = composition.overlay(note)
            
            # Adding the chord name to the output record.
            outputRecord.append("Chord" + str(listIndex) + ".wav") 
            
            # Exporting each chord using the current index as a name!
            composition.export("Chord" + str(listIndex) + ".wav",format="wav")

        # Increment the outer index to keep the naming correct!
        listIndex +=1 
    
    newLine()
    return outputRecord    


def assemble_chords_v1(outputRecord): # Deprecated

    """
    # Function to assemble the chords generated by generate_chord_library.
    # Initially just assembles one after another without care for time stamps or anything 
    # This is likely to change in later releases, hence the v1. 
    
    """    
    
    
    
    if outputRecord is None:
        return
    
    del outputRecord[-1]
    
    # We'll use this list to gather audio segments into one place. 
    
    finalCompositionList = []
    
   
    for chordName in outputRecord:
        
        chord = AudioSegment.from_wav(chordName)
        
        finalCompositionList.append(chord)
        
    
    finalComposition = AudioSegment.empty()
   

    for element in finalCompositionList:
        if GlobalParameters.chordSmoothing:
            finalComposition = finalComposition + element.fade_in(25).fade_out(25)
        else:
            finalComposition = finalComposition + element
        

    # Let's grab the time and date in order to name the final composition. 
    # Just some string replacement so can be used as a file name. 
    # As : is not allowed for windows file names. 
    
    now = str(datetime.now().time())
    now = now.replace(":","-")
    now = now[:7]    
    
    
    # Exporting!
    
    cd_root()
    
 
    finalComposition.export("LEGACY" + now + ".wav",format="wav")
    
    
    cd_dependencies()
    
    
    print("Build complete: Exported as LEGACY " + now + ".wav") 
    
    
    # Running clean up to automatically delete generated chords.
    
    clean_up_chord_library(outputRecord)


def generate_date_list(filename): # Deprecated
    
    """
    This function creates a list of days so that chord sequences can be built 
    according to time. 
    
    """
    
    cd_root()
    fastaFile = Seq(filename)
    cd_dependencies()
    rawSequenceList = fastaFile.seqList()
    rawDates =  fastaFile.getTitleList() # Uses the FASTAKit method to get a list of titles from the file. 
    
    #print(rawDates)
    #print("Length of raw dates",len(rawDates))
    
    daysList = [] # This will be used to store information about the number of days between each date.
    
    date_format = "%Y/%m/%d"
    for index in range(0,len(rawDates)-1):
        
        # Grabs two dates fromt the list to compare using the date time library. 
        try:
            firstDate = datetime.strptime(rawDates[index], date_format) 
            secondDate = datetime.strptime(rawDates[index+1], date_format)
        except:
            newLine()
            print("ERROR: Invalid Date Detected")
            print("Dates must be in the following format YYYY/MM/DD")
            return None
        
        # Compare the number of days between the two dates and append 
        # this value. 
        delta = secondDate - firstDate
        days = delta.days
        
        if days < 0:
            newLine()
            print("ERROR: Out of order date detected.")
            print("Only date ordered files are supported at this time.")
            return None
        
        daysList.append(days)
        
    
    daysList.append(1) # To account for the final date. 
    
    # Now we're going to run an additional check for the 0 values. 
    # If they were on the same day, but are different sequnces, we actually
    # want to include them. So will assign a day value of 1. 
    # Otherwise we'll leave them at 0 so they dont make it into 
    # the final composition. 
    
    for index in range(len(daysList) -1):
        if daysList[index] == 0:
                if rawSequenceList[index] != rawSequenceList[index+1]:
                    daysList[index] = 1
    
    #print(daysList)
    
    return daysList


def generate_date_list_modern(filename,timeSelection):
    
    """
    This function creates a list of days so that chord sequences can be built 
    according to time. 
    
    """
    
    cd_root()
    fastaFile = Seq(filename)
    cd_dependencies()
    rawSequenceList = fastaFile.seqList()
    rawDates =  fastaFile.getTitleList() # Uses the FASTAKit method to get a list of titles from the file. 
    
    #print(rawDates)
    #print("Length of raw dates",len(rawDates))
    
    daysList = [] # This will be used to store information about the number of days between each date.
    
    date_format = "%Y/%m/%d"
    for index in range(0,len(rawDates)-1):
        
        # Grabs two dates fromt the list to compare using the date time library. 
        try:
            firstDate = datetime.strptime(rawDates[index], date_format) 
            secondDate = datetime.strptime(rawDates[index+1], date_format)
        except:
            newLine()
            print("ERROR: Invalid Date Detected")
            print("Dates must be in the following format YYYY/MM/DD")
            return None
        
        # Compare the number of days between the two dates and append 
        # this value. 
        delta = secondDate - firstDate
        #print(delta)
        
        if timeSelection == 1:
            days = delta.days
            
            
        if timeSelection == 2:
            days = delta.days
            if days == 0:
                pass
            else:
                days = days / 30 
                days = round(days)
        
        if timeSelection == 3:
            days = delta.days
            if days == 0:
                pass
            else:
                days = days / 365 
                days = round(days)
        
        if days < 0:
            newLine()
            print("ERROR: Out of order date detected.")
            print("Only date ordered files are supported at this time.")
            return None
        
        daysList.append(days)
        
    
    daysList.append(1) # To account for the final date. =
    
    # Now we're going to run an additional check for the 0 values. 
    # If they were on the same day, but are different sequnces, we actually
    # want to include them. So will assign a day value of 1. 
    # Otherwise we'll leave them at 0 so they dont make it into 
    # the final composition. 
    
    for index in range(len(daysList) -1):
        if daysList[index] == 0:
                if rawSequenceList[index] != rawSequenceList[index+1]:
                    daysList[index] = 1
    
    #print(daysList)
    
    return daysList    


def assemble_chords_v2(outputRecord,daysList): # Deprecated
    
    """
    A brand new assembler that includes time scaled generation. 
    Sequences are appended multiple times depending on the number 
    of days between the previous sequence. 
    
    """
    
    if outputRecord is None:
        return
    
    # We'll use this list to gather audio segments into one place. 
    
    typeOfChord = outputRecord[-1]
    del(outputRecord[-1])
    
    
    finalCompositionList = []
    
    counter = 0 # Initialises a counter to iterate through the days list. 
    
    for chordName in outputRecord:
        
        chord = AudioSegment.from_wav(chordName)
        
        #newLine()
        #print("THIS IS THE DAY",daysList[counter])
        
        if daysList[counter] == 0:
            pass
        
        else:
            for i in range(daysList[counter]):

                #print("APPENDING",chordName)
                finalCompositionList.append(chord)
                
        
        counter += 1
        
    
    finalComposition = AudioSegment.empty()
   
    #print(finalCompositionList)
    #print(finalComposition)
    
    #newLine()
    for element in finalCompositionList:
        
        if GlobalParameters.chordSmoothing:
            finalComposition = finalComposition + element.fade_in(25).fade_out(25)
        else:
            finalComposition = finalComposition + element
        

    # Let's grab the time and date in order to name the final composition. 
    # Just some string replacement so can be used as a file name. 
    # As : is not allowed for windows file names. 
    
    now = str(datetime.now().time())
    now = now.replace(":","-")
    now = now[:7]    
    
    # Exporting!
    
    cd_root()
    if typeOfChord == "c":
        finalComposition.export("CLASSIC " + now + ".wav",format="wav")
        print("Build complete: Exported as CLASSIC " + now + ".wav") 
        
    elif typeOfChord == "a":
        finalComposition.export("ALTERNATE " + now + ".wav",format="wav")
        print("Build complete: Exported as ALTERNATE " + now + ".wav")         
        
    elif typeOfChord == "o":
        finalComposition.export("OSCILLATING " + now + ".wav",format="wav")
        print("Build complete: Exported as OSCILLATING " + now + ".wav") 
        
    elif typeOfChord == "ao":
        finalComposition.export("ALTERNATE OSCILLATING " + now + ".wav",format="wav")
        print("Build complete: Exported as ALTERNATE OSCILLATING " + now + ".wav")
        
    elif typeOfChord =="m":
        finalComposition.export("MINIMAL " + now + ".wav",format="wav")
        print("Build complete: Exported as MINIMAL " + now + ".wav") 
        
    elif typeOfChord == "ma":
        finalComposition.export("ALTERNATE MINIMAL " + now + ".wav",format="wav")
        print("Build complete: Exported as ALTERNATE MINIMAL " + now + ".wav")    
        
    elif typeOfChord == "mo":
        finalComposition.export("OSCILLATING MINIMAL " + now + ".wav",format="wav")
        print("Build complete: Exported as OSCILLATING MINIMAL " + now + ".wav") 
        
    
    elif typeOfChord == "moa":
        finalComposition.export("ALTERNATE OSCILLATING MINIMAL " + now + ".wav",format="wav")
        print("Build complete: Exported as ALTERNATE OSCILLATING MINIMAL " + now + ".wav") 
        
    else:
        print("ERROR: Critical System Failure")
        return
        
    
    cd_dependencies()
    
    
    
    
    # Running clean up to automatically delete generated chords.
    
    clean_up_chord_library(outputRecord)


def assemble_chords_modern(outputRecord,daysList):
    """
    A brand new assembler that includes time scaled generation. 
    Sequences are appended multiple times depending on the number 
    of days between the previous sequence. 
    
    """
    
    if outputRecord is None:
        return
    
    # We'll use this list to gather audio segments into one place. 
     
    
    finalCompositionList = []
    
    counter = 0 # Initialises a counter to iterate through the days list. 
    
    for chordName in outputRecord:
        
        chord = AudioSegment.from_wav(chordName)
        
        #newLine()
        #print("THIS IS THE DAY",daysList[counter])
        
        if daysList[counter] == 0:
            pass
        
        else:
            for i in range(daysList[counter]):

                #print("APPENDING",chordName)
                finalCompositionList.append(chord)
                
        
        counter += 1
        
    
    finalComposition = AudioSegment.empty()
   
    #print(finalCompositionList)
    #print(finalComposition)
    
    #newLine()
    for element in finalCompositionList:
        
        if GlobalParameters.chordSmoothing:
            finalComposition = finalComposition + element.fade_in(25).fade_out(25)
        else:
            finalComposition = finalComposition + element
        

    # Let's grab the time and date in order to name the final composition. 
    # Just some string replacement so can be used as a file name. 
    # As : is not allowed for windows file names. 
    
    now = str(datetime.now().time())
    now = now.replace(":","-")
    now = now[:7]    
    
    # Exporting!
    
    cd_root()
    
    finalComposition.export("Sonified Mutation Progression " + now + ".wav",format="wav")
    print("Build complete: Exported as Sonified Mutation Progression " + now + ".wav") 
        
        
    
    cd_dependencies()
    
    
    
    
    # Running clean up to automatically delete generated chords.
    
    clean_up_chord_library(outputRecord)    


def get_user_input_1(): # Deprecated

    
    """
    
    Gets user input regarding file name and alphabet selection. 
    Returns a string for filename and a boolean for alphabet selection if sucecssfull.
    Else returns none,none 
    
    """
    
    newLine()
    
    filename = input("Please enter the filename of the FASTA file you wish to use: \nOr press enter to use the default (sequences.fasta) \n")
    
    if filename == "":
        
        filename = "sequences.fasta"
        
    elif filename[-6:] != ".fasta":
        
        filename = filename + ".fasta"
    
    try:
        cd_root()
        file = open(filename)
        file.close()
        cd_dependencies()
    except:
        newLine()
        print("ERROR: File Does Not Exist")
        return None, None

    newLine()
    alphabetSelection = input("Would you like convert the data to a two letter (purine/pyrmidine) alphabet? [1] \nOr leave the data in its original format? [2] \n")
    
    if alphabetSelection == "1":
        convertToRY = True
    elif alphabetSelection == "2":
        convertToRY = False
    else:
        newLine()
        print("ERROR: Invalid Selection")
        return None, None
    
    return filename,convertToRY


def get_user_input_modern():
    
    """
    
    Gets user input regarding file name and alphabet selection. 
    Returns a string for filename and a boolean for alphabet selection if sucecssfull.
    Else returns none,none 
    
    """
    
    newLine()
    
    filename = input("Please enter the filename of the FASTA file you wish to use: \nOr press enter to use the default (sequences.fasta) \n")
    
    if filename == "":
        
        filename = "sequences.fasta"
        
    elif filename[-6:] != ".fasta":
        
        filename = filename + ".fasta"
    
    try:
        cd_root()
        file = open(filename)
        file.close()
        cd_dependencies()
    except:
        newLine()
        print("ERROR: File Does Not Exist")
        return None, None

    newLine()
    alphabetSelection = input("Would you like convert the data to a two letter (purine/pyrmidine) alphabet? [1] \nOr leave the data in its original format? [2] \n")
    
    if alphabetSelection == "1":
        convertToRY = True
    elif alphabetSelection == "2":
        convertToRY = False
    else:
        newLine()
        print("ERROR: Invalid Selection")
        return None, None
    
    
    newLine()
    timeSelection = input("Would you like to set the time scale to Day [1], Month [2] or year [3]? \n")
    
    if timeSelection == "1":
        timeSelection = 1
    elif timeSelection == "2":
        timeSelection = 2 
    elif timeSelection == "3":
        timeSelection = 3 
        
    else:
        newLine()
        print("ERROR: Invalid Selection")
        return None, None        
    
    
    
    
    return filename,convertToRY,timeSelection 
    

def clean_up_chord_library(ouputRecord):
    
    """
    Very simple function to clean up all the generated chords
    after they have been used to make the composition.
    Handy!

    """
    try:
        for element in ouputRecord:
            
            os.remove(element)    
    except:
        pass


def print_ASCI():
    
    print("  _   _   _   _     _   _   _   _   _  ")
    print(" / \ / \ / \ / \   / \ / \ / \ / \ / \ ")
    print("( V | i | r | u ) ( C | h | o | r | d )")
    print(" \_/ \_/ \_/ \_/   \_/ \_/ \_/ \_/ \_/ ")
  

def main():
    
    set_global_parameters()
    
    programChoice = None
    
    
    
    while programChoice != "4":
    
        newLine()
        
        print_ASCI()
        print (" Version "+ str(GlobalParameters.versionNumber))
    
        newLine()
        
        
        print("By Louis Cochrane - Lancaster University 2019")
        print("----------------------------------------------")
        print("[1] Generate Chord Progression")
        print("[2] Access Legacy Functionality")
        print("[3] Toggle Chord Smoothing")
        print("[4] Quit")
        print("----------------------------------------------")
        
        if GlobalParameters.chordSmoothing:
            print("Chord Smoothing: ENABLED")
        else:
            print("Chord Smoothing: DISABLED")
            
        newLine()
        programChoice = input()    
        
        
        if programChoice == "1":
            
            filename,convertToRY,timeSelection = get_user_input_modern()
            
            if filename is None or convertToRY is None:
                pass
            
            else:
                
                daysList = generate_date_list_modern(filename,timeSelection)
                if daysList is None:
                    pass
                else:
                    outputRecord = generate_chord_library_modern(filename,convertToRY)
                    assemble_chords_modern(outputRecord,daysList)     
        
        elif programChoice == "2":
        
            while programChoice != "11":
                
                newLine()
                
                print_ASCI()
                print (" Version "+ str(GlobalParameters.versionNumber))
            
                newLine()
                
                
                print(" By Louis Cochrane - Lancaster University 2019")
                print("--------------------------------------------------")
                print(" [1] Generate LEGACY")
                print(" [2] Generate CLASSIC")
                print(" [3] Generate ALTERNATE")
                print(" [4] Generate OSCILLATING")
                print(" [5] Generate ALTERNATE OSCILLATING")
                print(" [6] Generate MINIMAL")
                print(" [7] Generate ALTERNATE MINIMAL")
                print(" [8] Generate OSCILLATING MINIMAL  ")
                print(" [9] Generate All (May Take a While) ")
                print("[10] Toggle Chord Smoothing")
                print("[11] Return to Modern UI ")
                print("--------------------------------------------------")
                
                if GlobalParameters.chordSmoothing:
                    print(" Chord Smoothing: ENABLED")
                else:
                    print(" Chord Smoothing: DISABLED")
                    
                newLine()
                programChoice = input()
                
                
                if programChoice == "1":
                    
                    filename,convertToRY = get_user_input_1()
                    
                    if filename is None or convertToRY is None:
                        pass
                    else:
                        outputRecord = generate_chord_library(filename,convertToRY)
                        
                        assemble_chords_v1(outputRecord)
                        
                elif programChoice == "2":
                    
                    filename,convertToRY = get_user_input_1()
                    
                    if filename is None or convertToRY is None:
                        pass
                    
                    else:
                        
                        daysList = generate_date_list(filename)
                        if daysList is None:
                            pass
                        else:
                            outputRecord = generate_chord_library(filename,convertToRY)
                            assemble_chords_v2(outputRecord,daysList)  
                            
                            
                elif programChoice == "3":
                    
                    filename,convertToRY = get_user_input_1()
                    
                    if filename is None or convertToRY is None:
                        pass
                    
                    else:
                        
                        daysList = generate_date_list(filename)
                        if daysList is None:
                            pass
                        else:
                            outputRecord = generate_chord_library_alternate(filename,convertToRY)
                            assemble_chords_v2(outputRecord,daysList) 
                            
                elif programChoice == "4":
                    
                    filename,convertToRY = get_user_input_1()
                    
                    if filename is None or convertToRY is None:
                        pass
                    
                    else:
                        
                        daysList = generate_date_list(filename)
                        if daysList is None:
                            pass
                        else:
                            outputRecord = generate_chord_library_oscillating(filename,convertToRY)
                            assemble_chords_v2(outputRecord,daysList)     
                            
                elif programChoice == "5":
                    
                    filename,convertToRY = get_user_input_1()
                    
                    if filename is None or convertToRY is None:
                        pass
                    
                    else:
                        
                        daysList = generate_date_list(filename)
                        if daysList is None:
                            pass
                        else:
                            outputRecord = generate_chord_library_alternate_oscillating(filename,convertToRY)
                            assemble_chords_v2(outputRecord,daysList)
                            
                elif programChoice == "6":
                    
                    filename,convertToRY = get_user_input_1()
                    
                    if filename is None or convertToRY is None:
                        pass
                    
                    else:
                        
                        daysList = generate_date_list(filename)
                        if daysList is None:
                            pass
                        else:
                            outputRecord = generate_chord_library_minimal(filename,convertToRY)
                            assemble_chords_v2(outputRecord,daysList)  
                
                elif programChoice == "7":
                    
                    filename,convertToRY = get_user_input_1()
                    
                    if filename is None or convertToRY is None:
                        pass
                    
                    else:
                        
                        daysList = generate_date_list(filename)
                        if daysList is None:
                            pass
                        else:
                            outputRecord = generate_chord_library_minimal_alternate(filename,convertToRY)
                            assemble_chords_v2(outputRecord,daysList)         
                
                
                           
                elif programChoice == "8":
                    
                    filename,convertToRY = get_user_input_1()
                    
                    if filename is None or convertToRY is None:
                        pass
                    
                    else:
                        
                        daysList = generate_date_list(filename)
                        if daysList is None:
                            pass
                        else:
                            outputRecord = generate_chord_library_minimal_oscillating(filename,convertToRY)
                            assemble_chords_v2(outputRecord,daysList) 
                            
                
                     
                
                elif programChoice == "9":
                    
                    filename,convertToRY = get_user_input_1()
                    
                    if filename is None or convertToRY is None:
                        pass
                    
                    else:
                        
                        daysList = generate_date_list(filename)
                        if daysList is None:
                            pass
                        else:
                            
                            t1 = time.time()
                            
                            
                            outputRecord = generate_chord_library(filename,convertToRY)
                            assemble_chords_v1(outputRecord)
                            
                            outputRecord = generate_chord_library(filename,convertToRY)
                            assemble_chords_v2(outputRecord,daysList) 
                            
                            outputRecord = generate_chord_library_oscillating(filename,convertToRY)
                            assemble_chords_v2(outputRecord,daysList)                     
                            
                            outputRecord = generate_chord_library_alternate(filename,convertToRY)
                            assemble_chords_v2(outputRecord,daysList) 
                            
                            outputRecord = generate_chord_library_alternate_oscillating(filename,convertToRY)
                            assemble_chords_v2(outputRecord,daysList)                    
                            
                            outputRecord = generate_chord_library_minimal(filename,convertToRY)
                            assemble_chords_v2(outputRecord,daysList) 
                            
                            outputRecord = generate_chord_library_minimal_alternate(filename,convertToRY)
                            assemble_chords_v2(outputRecord,daysList)                    
                            
                            outputRecord = generate_chord_library_minimal_oscillating(filename,convertToRY)
                            assemble_chords_v2(outputRecord,daysList)                                         
                            
                            outputRecord = generate_chord_library_minimal_oscillating_alternate(filename,convertToRY)
                            assemble_chords_v2(outputRecord,daysList)   
                            
                            t2 = time.time()
                            
                            delta = t2 - t1 
                            delta = round(delta,2)
                            
                            newLine()
                            print("ALL BUILDS COMPLETE")
                            print("TIME TAKEN: " + str(delta) + "s")
                            newLine()
                
                elif programChoice == "10":
                    GlobalParameters.chordSmoothing = not GlobalParameters.chordSmoothing        
                
                
                elif programChoice == "11":
                    newLine()
                    newLine()
                    break
        
                else:
                    print("Invalid selection: please try again.")
        
        
        elif programChoice == "3": 
            GlobalParameters.chordSmoothing = not GlobalParameters.chordSmoothing        
        
        
        elif programChoice == "4":
            newLine()
            print("Shutting down - Goodbye!")
            newLine()
    
            return
    
        else:
            print("Invalid selection: please try again.")        



# Program Startup 

main()

